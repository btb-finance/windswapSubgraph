# Comprehensive CL Subgraph for WindSwap

# Protocol-wide statistics
type Protocol @entity {
  id: ID! # "windswap"
  totalVolumeUSD: BigDecimal!
  totalTVLUSD: BigDecimal!
  totalPools: BigInt!
  totalSwaps: BigInt!
  
  # Epoch info (from Minter) - eliminates RPC calls
  activePeriod: BigInt! # Current epoch start timestamp
  epochCount: BigInt! # Current epoch number
  epochDuration: BigInt! # Usually 604800 (1 week)
  epochEnd: BigInt! # When current epoch ends
  
  # Emissions tracking
  weeklyEmissions: BigDecimal! # WIND minted this week
  totalEmissions: BigDecimal! # Total WIND minted ever
  tailEmissionRate: BigDecimal! # Current tail emission rate
  
  # Voting data - eliminates RPC calls
  totalVotingWeight: BigInt! # Total veWIND across all pools
  
  # Governance parameters (eliminates RPC calls)
  proposalThreshold: BigInt! # from ProtocolGovernor
  votingDelay: BigInt! # from ProtocolGovernor
  votingPeriod: BigInt! # from ProtocolGovernor
  
  # Timestamps
  lastUpdated: BigInt!
}

# Token entity
type Token @entity {
  id: ID! # token address
  symbol: String!
  name: String!
  decimals: Int!
  totalVolumeUSD: BigDecimal!
  pools: [Pool!]! @derivedFrom(field: "token0")
}

  # CL Pool entity with full tracking
type Pool @entity {
  id: ID! # pool address
  factory: Bytes! # for CL vs V2 detection
  token0: Token!
  token1: Token!
  tickSpacing: Int!
  sqrtPriceX96: BigInt!
  tick: Int!
  liquidity: BigInt!
  
  # TVL tracking
  totalValueLockedToken0: BigDecimal!
  totalValueLockedToken1: BigDecimal!
  totalValueLockedUSD: BigDecimal!
  
  # Volume tracking
  volumeToken0: BigDecimal!
  volumeToken1: BigDecimal!
  volumeUSD: BigDecimal!
  
  # Fee tracking
  feesUSD: BigDecimal!
  
  # Counts
  txCount: BigInt!
  
  # Gauge link
  gauge: Gauge @derivedFrom(field: "pool")
  
  # LP tracking
  liquidityProviderCount: Int!
  liquidityProviders: [PoolLiquidityProvider!]! @derivedFrom(field: "pool")
  
  # Fees tracking
  weeklyFees: [PoolWeeklyFees!]! @derivedFrom(field: "pool")
  
  # Rewards tracking
  totalRewards: BigDecimal!
  
  # Timestamps
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
}

# Pool lookup helper for finding pools by token pair and tick spacing
# Used to link Positions to Pools
type PoolLookup @entity {
  id: ID! # token0-token1-tickSpacing
  pool: Pool!
  token0: Token!
  token1: Token!
  tickSpacing: Int!
}

# Individual swap event
type Swap @entity(immutable: true) {
  id: ID! # tx hash + log index
  pool: Pool!
  sender: Bytes!
  recipient: Bytes!
  amount0: BigDecimal!
  amount1: BigDecimal!
  amountUSD: BigDecimal!
  sqrtPriceX96: BigInt!
  tick: Int!
  timestamp: BigInt!
  blockNumber: BigInt!
  transaction: Bytes!
}

# Mint (add liquidity) event
type Mint @entity(immutable: true) {
  id: ID!
  pool: Pool!
  owner: Bytes!
  sender: Bytes!
  tickLower: Int!
  tickUpper: Int!
  amount: BigInt!
  amount0: BigDecimal!
  amount1: BigDecimal!
  amountUSD: BigDecimal!
  timestamp: BigInt!
  transaction: Bytes!
}

# Burn (remove liquidity) event
type Burn @entity(immutable: true) {
  id: ID!
  pool: Pool!
  owner: Bytes!
  tickLower: Int!
  tickUpper: Int!
  amount: BigInt!
  amount0: BigDecimal!
  amount1: BigDecimal!
  amountUSD: BigDecimal!
  timestamp: BigInt!
  transaction: Bytes!
}

# Daily pool data aggregation
type PoolDayData @entity {
  id: ID! # pool address + day timestamp
  pool: Pool!
  date: Int!
  
  # Volume
  volumeToken0: BigDecimal!
  volumeToken1: BigDecimal!
  volumeUSD: BigDecimal!
  
  # TVL at end of day
  tvlUSD: BigDecimal!
  
  # Fees
  feesUSD: BigDecimal!
  
  # Counts
  txCount: BigInt!
  
  # Price
  open: BigDecimal!
  high: BigDecimal!
  low: BigDecimal!
  close: BigDecimal!
}

# Hourly pool data for more granular tracking
type PoolHourData @entity {
  id: ID! # pool address + hour timestamp
  pool: Pool!
  periodStartTimestamp: Int!
  
  volumeToken0: BigDecimal!
  volumeToken1: BigDecimal!
  volumeUSD: BigDecimal!
  tvlUSD: BigDecimal!
  feesUSD: BigDecimal!
  txCount: BigInt!
}

# Protocol daily data
type ProtocolDayData @entity {
  id: ID! # day timestamp
  date: Int!
  totalVolumeUSD: BigDecimal!
  totalTVLUSD: BigDecimal!
  txCount: BigInt!
}

# ============================================
# GAUGE ENTITIES
# ============================================

# Gauge entity for both V2 and CL gauges
type Gauge @entity {
  id: ID! # gauge address
  pool: Pool!
  gaugeType: String! # "V2" or "CL"
  poolAddress: Bytes! # Raw pool address bytes
  
  # Staking data
  rewardRate: BigInt! # WIND per second
  totalStakedLiquidity: BigInt! # gauge.totalSupply()
  totalSupply: BigDecimal! # Total staked amount in gauge
  totalStaked: BigDecimal! # Same as totalSupply for compatibility
  
  # Gauge weight from Voter
  weight: BigInt! # Voter.weights(pool)
  
  # Bribe voting reward address
  bribeVotingReward: Bytes # Voter.bribeAddress(gauge)
  
  # Fee voting reward address
  feeVotingReward: Bytes # From Voter.GaugeCreated event
  
  # Status
  isActive: Boolean!
  
  # Staked positions
  stakedPositions: [GaugeStakedPosition!]! @derivedFrom(field: "gauge")
  
  # Investor tracking
  investorCount: Int!
  investors: [GaugeInvestor!]! @derivedFrom(field: "gauge")
  
  # Rewards tracking
  totalRewardsDistributed: BigDecimal!
  
  # Timestamps
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
  
  # Epoch-by-epoch voting data
  epochData: [GaugeEpochData!]! @derivedFrom(field: "gauge")
}

# Per-epoch gauge voting data (replaces RPC calls to Voter.weights)
type GaugeEpochData @entity {
  id: ID! # gaugeAddress-epochNumber
  gauge: Gauge!
  epoch: BigInt! # Epoch number
  
  # Voting data for this epoch
  votingWeight: BigInt! # Total veWIND voted for this gauge
  
  # Fee rewards distributed this epoch
  feeRewardToken0: BigDecimal! # Amount of token0 fees
  feeRewardToken1: BigDecimal! # Amount of token1 fees
  
  # Bribes added this epoch
  totalBribes: BigDecimal!
  
  # Emissions sent to this gauge
  emissions: BigDecimal! # WIND emissions
  
  timestamp: BigInt!
}

# User's staked position in a gauge
# NOTE: For CL positions, 'amount' stores liquidity (L). Frontend calculates token amounts using:
#   amount0 = L * (sqrt(Pb) - sqrt(P)) / (sqrt(P) * sqrt(Pb))
#   amount1 = L * (sqrt(P) - sqrt(Pa))
# Where P=current price from pool.tick, Pa/Pb=prices at tickLower/tickUpper
# See: windswapfrontend/src/utils/liquidityMath.ts
type GaugeStakedPosition @entity {
  id: ID! # userAddress-gaugeAddress-tokenId
  user: Bytes! # User wallet address (as Bytes)
  userId: String! # User wallet address (as lowercase string for querying)
  gauge: Gauge!
  
  # Link to Position entity for full position details (tick range, pool, etc.)
  position: Position
  
  # Staking data
  amount: BigDecimal! # Staked amount (liquidity for CL) - frontend calculates actual tokens
  
  # Rewards tracking
  earned: BigDecimal! # Total WIND rewards earned (not claimed)
  rewardPerTokenPaid: BigDecimal! # For reward calculation
  
  # NFT position for CL gauges
  tokenId: BigInt! # NFT token ID for CL positions
  
  # Position range info (denormalized for easy querying)
  tickLower: Int
  tickUpper: Int
  
  # Timestamps
  lastUpdateTimestamp: BigInt!
  createdAtTimestamp: BigInt!
}

# ============================================
# USER DATA ENTITIES
# ============================================

# User entity - aggregates all user data
type User @entity {
  id: ID! # wallet address (lowercase)
  positions: [Position!]! @derivedFrom(field: "owner")
  veNFTs: [VeNFT!]! @derivedFrom(field: "owner")
  totalPositions: BigInt!
  totalVeNFTs: BigInt!
  
  # Profile link
  profile: UserProfile @derivedFrom(field: "user")
}

# CL LP Position (from NonfungiblePositionManager)
# NOTE: Frontend calculates actual token amounts (amount0, amount1) from liquidity using:
#   amount0 = L * (sqrt(Pb) - sqrt(P)) / (sqrt(P) * sqrt(Pb))
#   amount1 = L * (sqrt(P) - sqrt(Pa))
# Where:
#   L = liquidity (constant, stored here)
#   P = current price from pool.tick (changes every swap)
#   Pa, Pb = price at tickLower, tickUpper
# Frontend formula: sqrt(1.0001^tick) for each tick, then apply above
# See: windswapfrontend/src/utils/liquidityMath.ts for implementation
type Position @entity {
  id: ID! # tokenId
  tokenId: BigInt!
  owner: User!
  pool: Pool!
  tickLower: Int!
  tickUpper: Int!
  liquidity: BigInt! # Constant L value
  
  # Current token amounts (calculated from liquidity + pool price)
  # Updated whenever position liquidity changes
  amount0: BigDecimal! # Current amount of token0 in position
  amount1: BigDecimal! # Current amount of token1 in position
  
  depositedToken0: BigDecimal! # Historical: what user originally deposited
  depositedToken1: BigDecimal! # Historical: what user originally deposited
  withdrawnToken0: BigDecimal!
  withdrawnToken1: BigDecimal!
  collectedToken0: BigDecimal!
  collectedToken1: BigDecimal!
  staked: Boolean!
  stakedGauge: Bytes
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
  
  # Fees tracking
  fees: PositionFees @derivedFrom(field: "position")
}

# Voting Escrow NFT (locked WIND)
type VeNFT @entity {
  id: ID! # tokenId
  tokenId: BigInt!
  owner: User!
  lockedAmount: BigDecimal! # Amount of WIND locked
  lockEnd: BigInt! # Unix timestamp when lock expires
  votingPower: BigDecimal! # Current voting power
  isPermanent: Boolean! # TRUE = max lock (no expiration)
  createdAtTimestamp: BigInt! # When veNFT was created
  
  # Rewards fields
  claimableRewards: BigDecimal! # WIND available to claim
  totalClaimed: BigDecimal! # Total WIND claimed historically
  rewards: [VeNFTRewards!]! @derivedFrom(field: "veNFT")
  weeklyRebases: [VeNFTWeeklyRebase!]! @derivedFrom(field: "veNFT")
  
  # Voting status (eliminates RPC calls)
  lastVoted: BigInt! # Last time voted
  hasVoted: Boolean! # TRUE = voted this epoch
  votes: [VeVote!]! @derivedFrom(field: "veNFT")
  votingRewards: [VotingRewardBalance!]! @derivedFrom(field: "veNFT")
  
  # Computed fields (frontend calculates from above)
  # timeUntilUnlock: lockEnd - currentTime (calculated in UI)
  # maxVotingPower: votingPower if locked for 4 years (calculated in UI)
}

# Vote entity for veNFT voting on pools
# Query: veVotes(where: { user: "0x...", epoch: $currentEpoch }) to get THIS EPOCH's votes
type VeVote @entity {
  id: ID! # veNFT-pool (ensures one vote per pool per veNFT, updates on change)
  user: User! # Direct link to user for easy querying
  veNFT: VeNFT! # Which veNFT was used to vote
  pool: Pool! # Which pool was voted for
  weight: BigInt! # Voting weight assigned
  epoch: BigInt! # Which epoch this vote is for
  timestamp: BigInt! # When the vote happened
  isActive: Boolean! # TRUE = current vote for this epoch
  
  # Voting rewards earned from this vote
  feesEarnedToken0: BigDecimal! # Fees earned in token0
  feesEarnedToken1: BigDecimal! # Fees earned in token1
  bribesEarned: BigDecimal! # Bribes earned
}

# Voting reward balance for veNFT on specific gauge/token
type VotingRewardBalance @entity {
  id: ID! # veNFT + token + gauge
  veNFT: VeNFT!
  token: Token!
  gauge: Gauge!
  amount: BigInt!
  epoch: BigInt!
}

# Track claimed voting rewards (fees + bribes) - replaces RPC calls
type VotingRewardClaim @entity {
  id: ID! # txHash-logIndex
  veNFT: VeNFT!
  user: User! # For easy querying
  gauge: Gauge!
  pool: Pool!
  
  # What was claimed
  token0Amount: BigDecimal! # Fee in token0
  token1Amount: BigDecimal! # Fee in token1
  bribeAmount: BigDecimal! # Bribe amount
  bribeToken: Token # Which token for bribe
  
  # Epoch info
  epoch: BigInt!
  timestamp: BigInt!
}

# VeNFT rewards tracking
type VeNFTRewards @entity {
  id: ID! # veNFT tokenId
  veNFT: VeNFT!
  claimable: BigDecimal! # Rewards available to claim
  claimed: BigDecimal! # Total rewards claimed
  rebases: BigDecimal! # Rebase rewards earned
  incentives: BigDecimal! # Incentive rewards
  lastClaimTimestamp: BigInt!
}

# Weekly rebase tracking per veNFT - shows how much earned each week
type VeNFTWeeklyRebase @entity {
  id: ID! # veNFT-weekNumber
  veNFT: VeNFT!
  weekNumber: Int! # Week number (timestamp / 604800)
  amount: BigDecimal! # WIND earned this week
  timestamp: BigInt! # When the rebase was claimed
  txHash: String! # Transaction hash for reference
}

# Gauge investor tracking
type GaugeInvestor @entity {
  id: ID! # userAddress-gaugeAddress
  user: Bytes!
  gauge: Gauge!
  investedAmount: BigDecimal!
  totalInvested: BigDecimal! # Historical total
  totalWithdrawn: BigDecimal!
  firstInvestTimestamp: BigInt!
  lastInvestTimestamp: BigInt!
}

# Pool weekly fees tracking
type PoolWeeklyFees @entity {
  id: ID! # poolAddress-weekNumber
  pool: Pool!
  week: Int! # Week number (timestamp / 604800)
  feesToken0: BigDecimal!
  feesToken1: BigDecimal!
  feesUSD: BigDecimal!
  rewardsDistributed: BigDecimal! # WIND rewards to gauge
  liquidityProvidersCount: Int!
}

# Position fees tracking
type PositionFees @entity {
  id: ID! # positionTokenId
  position: Position!
  feesToken0: BigDecimal! # Total fees earned
  feesToken1: BigDecimal!
  feesUSD: BigDecimal!
  lastCollectTimestamp: BigInt!
  collectCount: Int!
}

# Pool liquidity provider tracking
type PoolLiquidityProvider @entity {
  id: ID! # poolAddress-userAddress
  pool: Pool!
  user: Bytes!
  totalLiquidity: BigInt!
  totalPositions: Int!
  firstProvideTimestamp: BigInt!
  lastProvideTimestamp: BigInt!
  totalValueUSD: BigDecimal!
}

# Enhanced user profile
type UserProfile @entity {
  id: ID! # user address
  user: User!
  
  # Total portfolio value
  totalPositionsValueUSD: BigDecimal!
  totalStakedValueUSD: BigDecimal!
  totalVeNFTValueUSD: BigDecimal!
  
  # Rewards earned
  totalRewardsClaimedUSD: BigDecimal!
  totalFeesEarnedUSD: BigDecimal!
  
  # Activity stats
  totalSwaps: Int!
  totalProvides: Int!
  totalWithdraws: Int!
  
  # NFT holdings (access via user.positions and user.veNFTs)
  
  # First/last activity
  firstActivityTimestamp: BigInt!
  lastActivityTimestamp: BigInt!
}

# Fee collection from position
type Collect @entity(immutable: true) {
  id: ID! # tx-logIndex
  position: Position!
  recipient: Bytes!
  amount0: BigDecimal!
  amount1: BigDecimal!
  timestamp: BigInt!
  transaction: Bytes!
}

# Position snapshot for historical tracking
type PositionSnapshot @entity(immutable: true) {
  id: ID!
  position: Position!
  liquidity: BigInt!
  depositedToken0: BigDecimal!
  depositedToken1: BigDecimal!
  timestamp: BigInt!
  blockNumber: BigInt!
}

# ============================================
# GOVERNANCE ENTITIES
# ============================================

# Governance Proposal
type Proposal @entity {
  id: ID! # proposalId (hex)
  proposalId: BigInt!
  proposer: Bytes!
  targets: [Bytes!]!
  values: [BigInt!]!
  calldatas: [Bytes!]!
  description: String!
  
  # Voting times (timestamps, not blocks)
  voteStart: BigInt!
  voteEnd: BigInt!
  
  # Vote tallies
  forVotes: BigInt!
  againstVotes: BigInt!
  abstainVotes: BigInt!
  
  # State tracking
  state: Int! # 0=Pending, 1=Active, 2=Canceled, 3=Defeated, 4=Succeeded, 5=Queued, 6=Expired, 7=Executed
  executed: Boolean!
  canceled: Boolean!
  
  # Timestamps
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
  executedAtTimestamp: BigInt
}

# Individual vote on a proposal
type ProposalVote @entity(immutable: true) {
  id: ID! # proposalId-voter
  proposal: Proposal!
  voter: Bytes!
  tokenId: BigInt!
  support: Int! # 0=Against, 1=For, 2=Abstain
  weight: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}
